<p align="center"><b>МОНУ НТУУ КПІ ім. Ігоря Сікорського ФПМ СПіСКС</b></p>
<p align="center">
<b>Звіт з лабораторної роботи 3</b><br/>
"Конструктивний і деструктивний підходи до роботи зі списками"<br/>
дисципліни "Вступ до функціонального програмування"
</p>

<p align="right"><b>Студент(-ка)</b>: <i>Коротич Олександр Сергійович КВ-11</i><p>
<p align="right"><b>Рік</b>: <i>2024</i><p>

## Хід виконання роботи:

## Загальне завдання:

Реалізуйте алгоритм сортування чисел у списку двома способами: функціонально і
імперативно.
1. Функціональний варіант реалізації має базуватись на використанні рекурсії і
конструюванні нових списків щоразу, коли необхідно виконати зміну вхідного
списку. Не допускається використання: деструктивних операцій, циклів, функцій
вищого порядку або функцій для роботи зі списками/послідовностями, що
використовуються як функції вищого порядку. Також реалізована функція не має
бути функціоналом (тобто приймати на вхід функції в якості аргументів).
2. Імперативний варіант реалізації має базуватись на використанні циклів і
деструктивних функцій (псевдофункцій). Не допускається використання функцій
вищого порядку або функцій для роботи зі списками/послідовностями, що
використовуються як функції вищого порядку. Тим не менш, оригінальний список
цей варіант реалізації також не має змінювати, тому перед виконанням
деструктивних змін варто застосувати функцію copy-list (в разі необхідності).
Також реалізована функція не має бути функціоналом (тобто приймати на вхід
функції в якості аргументів).
Алгоритм, який необхідно реалізувати, задається варіантом (п. 3.1.1). Зміст і шаблон
звіту наведені в п. 3.2.
Кожна реалізована функція має бути протестована для різних тестових наборів. Тести
мають бути оформленні у вигляді модульних тестів (наприклад, як наведено у п. 2.3).

## Варіан 2

Алгоритм сортування обміном №1 (без оптимізацій) за незменшенням.

## Лістинг функції з використанням конструктивного підходу
```lisp
(defun functional-bubble-sort (lst)
  (if (null (cdr lst))
      lst
      (let ((rest (functional-bubble-sort (cdr lst))))
        (if (> (car lst) (car rest))
            (cons (car rest) (functional-bubble-sort (cons (car lst) (cdr rest))))
            (cons (car lst) rest)))))

(defun sort-list (lst)
  (when lst
      (functional-bubble-sort lst)))
```
### Тестові набори
```lisp
(defun test-functional-sort ()
  (format t "Testing functional-bubble-sort:~%")
  (check-result "test 1" #'sort-list '(1 2 3 5 3 0 2) '(0 1 2 2 3 3 5))
  (check-result "test 2" #'sort-list '(5 4 3 2 1) '(1 2 3 4 5))
  (check-result "test 3" #'sort-list nil nil))
```
### Тестування
```lisp
Testing functional-bubble-sort:
passed... test 1
passed... test 2
passed... test 3
```
## Лістинг функції з використанням деструктивного підходу
```lisp
(defun imperative-bubble-sort (lst)
  (let ((sorted-list (copy-list lst)) (n (length lst)))
    (loop for i from 0 below (- n 1)
          do (loop for j from 0 below (- n i 1)
                   do (when (> (nth j sorted-list) (nth (+ 1 j) sorted-list))
                        (rotatef (nth j sorted-list) (nth (+ 1 j) sorted-list)))))
    sorted-list))
```
### Тестові набори
```lisp
(defun test-imperative-sort ()
  (format t "~%Testing imperative-bubble-sort:~%")
  (check-result "test 1" #'imperative-bubble-sort '(1 2 3 5 3 0 2) '(0 1 2 2 3 3 5))
  (check-result "test 2" #'imperative-bubble-sort '(5 4 3 2 1) '(1 2 3 4 5))
  (check-result "test 3" #'imperative-bubble-sort nil nil))
```
### Тестування
```lisp
Testing imperative-bubble-sort:
passed... test 1
passed... test 2
passed... test 3
NIL
```